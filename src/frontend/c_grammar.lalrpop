use std::str::FromStr;
use crate::backend::ast::ast::{Function, Program, Statement, Expression, BinaryOp, UnaryOp};

grammar;


pub Program: Program = {
  <f: Func> => Program::Func(f)
};

ID: String = {
  <s:r"[a-zA-Z][a-zA-Z0-9]*"> => s.to_owned(),
}

Func: Function = {
  "int" <id: ID> "(" "void" ")" "{" <s : Statement> "}" => {
    Function{name: id, body: s}
  }
};


Statement: Statement = {
  "return" <e: Expression> ";" => Statement::Return(e),
};

Expression: Expression = {
    Term,
    <e1:Expression> "+" <e2:Term> => Expression::Binary(BinaryOp::Add, Box::new(e1), Box::new(e2)),
    <e1:Expression> "-" <e2:Term> => Expression::Binary(BinaryOp::Sub, Box::new(e1), Box::new(e2)),
};

Term: Expression = {
    Factor,
    <e1:Term> "*" <e2:Factor> => Expression::Binary(BinaryOp::Mul, Box::new(e1), Box::new(e2)),
    <e1:Term> "/" <e2:Factor> => Expression::Binary(BinaryOp::Div, Box::new(e1), Box::new(e2)),
    <e1:Term> "%" <e2:Factor> => Expression::Binary(BinaryOp::Mod, Box::new(e1), Box::new(e2)),
};

Factor: Expression = {
    r"[0-9]+" => Expression::Int(i32::from_str(<>).unwrap()),
    "-" <e:Factor> => Expression::Unary(UnaryOp::Neg, Box::new(e)),
    "--" <e:Factor> => Expression::Unary(UnaryOp::PrefixDec, Box::new(e)),
    "~" <e:Factor> => Expression::Unary(UnaryOp::Complement, Box::new(e)),
    "(" <e:Expression> ")" => e,
};

