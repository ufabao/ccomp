use std::str::FromStr;
use crate::backend::ast::{Function, BlockItem, Declaration, Program, Statement, Expression, BinaryOp, UnaryOp};

grammar;

pub Program: Program = {
    <f: Func> => Program::Func(f)
};

ID: String = {
    <s:r"[a-zA-Z][a-zA-Z0-9]*"> => s.to_owned(),
}

Func: Function = {
    "int" <id: ID> "(" "void" ")" "{" <b: BlockItems> "}" => {
        Function{name: id, body: b}
    }
};

BlockItems: Vec<BlockItem> = {
  <b: BlockItem> => vec![b],
  <mut v: BlockItems> <b: BlockItem> => {
    v.push(b);
    v
  }
}

BlockItem: BlockItem = {
  <s: Statement> => BlockItem::Statement(<>),
  <d: Declaration> => BlockItem::Declaration(<>),
}

Declaration: Declaration = {
  "int" <name: ID> ";" => Declaration{ name: name, exp: None },
  "int" <name: ID> "=" <e : Exp> ";" => Declaration { name: name, exp: Some(e) },
}

Statement: Statement = {
    #[precedence(level="0")]
    "return" <e: Exp> ";" => Statement::Return(e),
    <e: Exp> ";" => Statement::Expression(e),
    #[precedence(level="5")]
    "if" "(" <e1 : Exp> ")" <s1 : Statement> "else" <s2 : Statement> => Statement::If(e1, Box::new(s1), Some(Box::new(s2))),
    #[precedence(level="10")]
    "if" "(" <e1 : Exp> ")" <s : Statement> => Statement::If(e1, Box::new(s), None),
    #[precedence(level="20")]
    ";" => Statement::Null,
};

Exp: Expression = {
    #[precedence(level="0")]
    Factor,

    #[precedence(level="110")]
    #[assoc(side="right")]
    <e1: Exp> "=" <e2: Exp> => Expression::Assignment(Box::new(e1), Box::new(e2)),

    #[precedence(level="100")]
    #[assoc(side="right")]
    <e1 : Exp> "?" <e2 : Exp> ":" <e3 : Exp> => Expression::Conditional(Box::new(e1), Box::new(e2), Box::new(e3)),
    
    #[precedence(level="95")]
    #[assoc(side="left")]
    <e1: Exp> "||" <e2:Exp> => Expression::Binary(BinaryOp::Or, Box::new(e1), Box::new(e2)),
    
    #[precedence(level="90")]
    #[assoc(side="left")]
    <e1: Exp> "&&" <e2:Exp> => Expression::Binary(BinaryOp::And, Box::new(e1), Box::new(e2)),
    
    #[precedence(level="70")]
    #[assoc(side="left")]
    <e1: Exp> "==" <e2:Exp> => Expression::Binary(BinaryOp::Equal, Box::new(e1), Box::new(e2)),
    <e1: Exp> "!=" <e2:Exp> => Expression::Binary(BinaryOp::NotEqual, Box::new(e1), Box::new(e2)),
    
    #[precedence(level="65")]
    #[assoc(side="left")]
    <e1: Exp> "<" <e2:Exp> => Expression::Binary(BinaryOp::LessThan, Box::new(e1), Box::new(e2)),
    <e1: Exp> "<=" <e2:Exp> => Expression::Binary(BinaryOp::LessOrEqual, Box::new(e1), Box::new(e2)),
    <e1: Exp> ">" <e2:Exp> => Expression::Binary(BinaryOp::GreaterThan, Box::new(e1), Box::new(e2)),
    <e1: Exp> ">=" <e2:Exp> => Expression::Binary(BinaryOp::GreaterOrEqual, Box::new(e1), Box::new(e2)),
    
    #[precedence(level="55")]
    #[assoc(side="left")]
    <e1:Exp> "+" <e2:Exp> => Expression::Binary(BinaryOp::Add, Box::new(e1), Box::new(e2)),
    <e1:Exp> "-" <e2:Exp> => Expression::Binary(BinaryOp::Sub, Box::new(e1), Box::new(e2)),
    
    #[precedence(level="50")]
    #[assoc(side="left")]
    <e1:Exp> "*" <e2:Exp> => Expression::Binary(BinaryOp::Mul, Box::new(e1), Box::new(e2)),
    <e1:Exp> "/" <e2:Exp> => Expression::Binary(BinaryOp::Div, Box::new(e1), Box::new(e2)),
    <e1:Exp> "%" <e2:Exp> => Expression::Binary(BinaryOp::Mod, Box::new(e1), Box::new(e2)),
};

Factor: Expression = {
    r"[0-9]+" => Expression::Int(i32::from_str(<>).unwrap()),
    <name: ID> => Expression::Var(name),
    "-" <e: Factor> => Expression::Unary(UnaryOp::Neg, Box::new(e)),
    "~" <e: Factor> => Expression::Unary(UnaryOp::Complement, Box::new(e)),
    "!" <e: Factor> => Expression::Unary(UnaryOp::Not, Box::new(e)),
    "(" <e: Exp> ")" => e,
};